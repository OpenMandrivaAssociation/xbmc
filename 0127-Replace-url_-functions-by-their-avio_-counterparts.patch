From 8a13552edc0c2f23f9943e984517741874f14139 Mon Sep 17 00:00:00 2001
From: Alexis Ballier <aballier@gentoo.org>
Date: Thu, 1 Mar 2012 11:43:16 -0300
Subject: [PATCH 127/145] Replace url_* functions by their avio_*
 counterparts. (cherry picked from commit
 c5774f92ea4a458fb354d2f1852800d0917239bb)

---
 lib/DllAvFormat.h                                  |   92 ++++++++++----------
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.cpp |   48 +++++-----
 .../DVDCodecs/Video/DVDVideoCodecVideoToolBox.cpp  |   86 +++++++++---------
 .../cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp |    4 +-
 4 files changed, 113 insertions(+), 117 deletions(-)

diff --git a/lib/DllAvFormat.h b/lib/DllAvFormat.h
index 7f88c7b..7ac02e7 100644
--- a/lib/DllAvFormat.h
+++ b/lib/DllAvFormat.h
@@ -81,18 +81,17 @@ public:
   virtual AVInputFormat *av_probe_input_format2(AVProbeData *pd, int is_opened, int *score_max)=0;
   virtual int av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt, const char *filename, void *logctx, unsigned int offset, unsigned int max_probe_size)=0;
   virtual void av_dump_format(AVFormatContext *ic, int index, const char *url, int is_output)=0;
-  virtual int url_fopen(AVIOContext **s, const char *filename, int flags)=0;
-  virtual int url_fclose(AVIOContext *s)=0;
-  virtual int url_open_dyn_buf(AVIOContext **s)=0;
-  virtual int url_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)=0;
-  virtual offset_t url_fseek(AVIOContext *s, offset_t offset, int whence)=0;
-  virtual int get_buffer(AVIOContext *s, unsigned char *buf, int size)=0;
-  virtual int get_partial_buffer(AVIOContext *s, unsigned char *buf, int size)=0;
-  virtual void put_byte(AVIOContext *s, int b)=0;
-  virtual void put_buffer(AVIOContext *s, const unsigned char *buf, int size)=0;
-  virtual void put_be24(AVIOContext *s, unsigned int val)=0;
-  virtual void put_be32(AVIOContext *s, unsigned int val)=0;
-  virtual void put_be16(AVIOContext *s, unsigned int val)=0;
+  virtual int avio_open(AVIOContext **s, const char *filename, int flags)=0;
+  virtual int avio_close(AVIOContext *s)=0;
+  virtual int avio_open_dyn_buf(AVIOContext **s)=0;
+  virtual int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)=0;
+  virtual offset_t avio_seek(AVIOContext *s, offset_t offset, int whence)=0;
+  virtual int avio_read(AVIOContext *s, unsigned char *buf, int size)=0;
+  virtual void avio_w8(AVIOContext *s, int b)=0;
+  virtual void avio_write(AVIOContext *s, const unsigned char *buf, int size)=0;
+  virtual void avio_wb24(AVIOContext *s, unsigned int val)=0;
+  virtual void avio_wb32(AVIOContext *s, unsigned int val)=0;
+  virtual void avio_wb16(AVIOContext *s, unsigned int val)=0;
   virtual AVFormatContext *avformat_alloc_context(void)=0;
   virtual AVStream *avformat_new_stream(AVFormatContext *s, AVCodec *c)=0;
   virtual AVOutputFormat *av_guess_format(const char *short_name, const char *filename, const char *mime_type)=0;
@@ -141,18 +140,17 @@ public:
   virtual AVInputFormat *av_probe_input_format2(AVProbeData *pd, int is_opened, int *score_max) {*score_max = 100; return ::av_probe_input_format(pd, is_opened); } // Use av_probe_input_format, this is not exported by ffmpeg's headers
   virtual int av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt, const char *filename, void *logctx, unsigned int offset, unsigned int max_probe_size) { return ::av_probe_input_buffer(pb, fmt, filename, logctx, offset, max_probe_size); }
   virtual void av_dump_format(AVFormatContext *ic, int index, const char *url, int is_output) { ::av_dump_format(ic, index, url, is_output); }
-  virtual int url_fopen(AVIOContext **s, const char *filename, int flags) { return ::url_fopen(s, filename, flags); }
-  virtual int url_fclose(AVIOContext *s) { return ::url_fclose(s); }
-  virtual int url_open_dyn_buf(AVIOContext **s) { return ::url_open_dyn_buf(s); }
-  virtual int url_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer) { return ::url_close_dyn_buf(s, pbuffer); }
-  virtual offset_t url_fseek(AVIOContext *s, offset_t offset, int whence) { return ::url_fseek(s, offset, whence); }
-  virtual int get_buffer(AVIOContext *s, unsigned char *buf, int size) { return ::get_buffer(s, buf, size); }
-  virtual int get_partial_buffer(AVIOContext *s, unsigned char *buf, int size) { return ::get_partial_buffer(s, buf, size); }
-  virtual void put_byte(AVIOContext *s, int b) { ::put_byte(s, b); }
-  virtual void put_buffer(AVIOContext *s, const unsigned char *buf, int size) { ::put_buffer(s, buf, size); }
-  virtual void put_be24(AVIOContext *s, unsigned int val) { ::put_be24(s, val); }
-  virtual void put_be32(AVIOContext *s, unsigned int val) { ::put_be32(s, val); }
-  virtual void put_be16(AVIOContext *s, unsigned int val) { ::put_be16(s, val); }
+  virtual int avio_open(AVIOContext **s, const char *filename, int flags) { return ::avio_open(s, filename, flags); }
+  virtual int avio_close(AVIOContext *s) { return ::avio_close(s); }
+  virtual int avio_open_dyn_buf(AVIOContext **s) { return ::avio_open_dyn_buf(s); }
+  virtual int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer) { return ::avio_close_dyn_buf(s, pbuffer); }
+  virtual offset_t avio_seek(AVIOContext *s, offset_t offset, int whence) { return ::avio_seek(s, offset, whence); }
+  virtual int avio_read(AVIOContext *s, unsigned char *buf, int size) { return ::avio_read(s, buf, size); }
+  virtual void avio_w8(AVIOContext *s, int b) { ::avio_w8(s, b); }
+  virtual void avio_write(AVIOContext *s, const unsigned char *buf, int size) { ::avio_write(s, buf, size); }
+  virtual void avio_wb24(AVIOContext *s, unsigned int val) { ::avio_wb24(s, val); }
+  virtual void avio_wb32(AVIOContext *s, unsigned int val) { ::avio_wb32(s, val); }
+  virtual void avio_wb16(AVIOContext *s, unsigned int val) { ::avio_wb16(s, val); }
   virtual AVFormatContext *avformat_alloc_context() { return ::avformat_alloc_context(); }
   virtual AVStream *avformat_new_stream(AVFormatContext *s, AVCodec *c) { return ::avformat_new_stream(s, c); }
   virtual AVOutputFormat *av_guess_format(const char *short_name, const char *filename, const char *mime_type) { return ::av_guess_format(short_name, filename, mime_type); }
@@ -195,23 +193,22 @@ class DllAvFormat : public DllDynamic, DllAvFormatInterface
   DEFINE_FUNC_ALIGNED2(AVInputFormat*, __cdecl, av_probe_input_format, AVProbeData*, int)
   DEFINE_FUNC_ALIGNED3(AVInputFormat*, __cdecl, av_probe_input_format2, AVProbeData*, int, int*)
   DEFINE_FUNC_ALIGNED6(int, __cdecl, av_probe_input_buffer, AVIOContext *, AVInputFormat **, const char *, void *, unsigned int, unsigned int)
-  DEFINE_FUNC_ALIGNED3(int, __cdecl, get_buffer, AVIOContext*, unsigned char *, int)
-  DEFINE_FUNC_ALIGNED3(int, __cdecl, get_partial_buffer, AVIOContext*, unsigned char *, int)
-  DEFINE_FUNC_ALIGNED2(void, __cdecl, put_byte, AVIOContext*, int)
-  DEFINE_FUNC_ALIGNED3(void, __cdecl, put_buffer, AVIOContext*, const unsigned char *, int)
-  DEFINE_FUNC_ALIGNED2(void, __cdecl, put_be24, AVIOContext*, unsigned int)
-  DEFINE_FUNC_ALIGNED2(void, __cdecl, put_be32, AVIOContext*, unsigned int)
-  DEFINE_FUNC_ALIGNED2(void, __cdecl, put_be16, AVIOContext*, unsigned int)
+  DEFINE_FUNC_ALIGNED3(int, __cdecl, avio_read, AVIOContext*, unsigned char *, int)
+  DEFINE_FUNC_ALIGNED2(void, __cdecl, avio_w8, AVIOContext*, int)
+  DEFINE_FUNC_ALIGNED3(void, __cdecl, avio_write, AVIOContext*, const unsigned char *, int)
+  DEFINE_FUNC_ALIGNED2(void, __cdecl, avio_wb24, AVIOContext*, unsigned int)
+  DEFINE_FUNC_ALIGNED2(void, __cdecl, avio_wb32, AVIOContext*, unsigned int)
+  DEFINE_FUNC_ALIGNED2(void, __cdecl, avio_wb16, AVIOContext*, unsigned int)
   DEFINE_METHOD7(AVIOContext *, avio_alloc_context, (unsigned char *p1, int p2, int p3, void *p4,
                   int (*p5)(void *opaque, uint8_t *buf, int buf_size),
                   int (*p6)(void *opaque, uint8_t *buf, int buf_size),
                   offset_t (*p7)(void *opaque, offset_t offset, int whence)))
   DEFINE_METHOD4(void, av_dump_format, (AVFormatContext *p1, int p2, const char *p3, int p4))
-  DEFINE_METHOD3(int, url_fopen, (AVIOContext **p1, const char *p2, int p3))
-  DEFINE_METHOD1(int, url_fclose, (AVIOContext *p1))
-  DEFINE_METHOD1(int, url_open_dyn_buf, (AVIOContext **p1))
-  DEFINE_METHOD2(int, url_close_dyn_buf, (AVIOContext *p1, uint8_t **p2))
-  DEFINE_METHOD3(offset_t, url_fseek, (AVIOContext *p1, offset_t p2, int p3))
+  DEFINE_METHOD3(int, avio_open, (AVIOContext **p1, const char *p2, int p3))
+  DEFINE_METHOD1(int, avio_close, (AVIOContext *p1))
+  DEFINE_METHOD1(int, avio_open_dyn_buf, (AVIOContext **p1))
+  DEFINE_METHOD2(int, avio_close_dyn_buf, (AVIOContext *p1, uint8_t **p2))
+  DEFINE_METHOD3(offset_t, avio_seek, (AVIOContext *p1, offset_t p2, int p3))
   DEFINE_METHOD0(AVFormatContext *, avformat_alloc_context)
   DEFINE_METHOD2(AVStream *, avformat_new_stream, (AVFormatContext *p1, AVCodec *p2))
   DEFINE_METHOD3(AVOutputFormat *, av_guess_format, (const char *p1, const char *p2, const char *p3))
@@ -239,18 +236,17 @@ class DllAvFormat : public DllDynamic, DllAvFormatInterface
     RESOLVE_METHOD(av_probe_input_format2)
     RESOLVE_METHOD(av_probe_input_buffer)
     RESOLVE_METHOD(av_dump_format)
-    RESOLVE_METHOD(url_fopen)
-    RESOLVE_METHOD(url_fclose)
-    RESOLVE_METHOD(url_open_dyn_buf)
-    RESOLVE_METHOD(url_close_dyn_buf)
-    RESOLVE_METHOD(url_fseek)
-    RESOLVE_METHOD(get_buffer)
-    RESOLVE_METHOD(get_partial_buffer)
-    RESOLVE_METHOD(put_byte)
-    RESOLVE_METHOD(put_buffer)
-    RESOLVE_METHOD(put_be24)
-    RESOLVE_METHOD(put_be32)
-    RESOLVE_METHOD(put_be16)
+    RESOLVE_METHOD(avio_open)
+    RESOLVE_METHOD(avio_close)
+    RESOLVE_METHOD(avio_open_dyn_buf)
+    RESOLVE_METHOD(avio_close_dyn_buf)
+    RESOLVE_METHOD(avio_seek)
+    RESOLVE_METHOD(avio_read)
+    RESOLVE_METHOD(avio_w8)
+    RESOLVE_METHOD(avio_write)
+    RESOLVE_METHOD(avio_wb24)
+    RESOLVE_METHOD(avio_wb32)
+    RESOLVE_METHOD(avio_wb16)
     RESOLVE_METHOD(avformat_alloc_context)
     RESOLVE_METHOD(avformat_new_stream)
     RESOLVE_METHOD(av_guess_format)
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.cpp
index 0238864..c9f0650 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.cpp
@@ -525,8 +525,8 @@ const int avc_parse_nal_units(DllAvFormat *av_format_ctx,
   {
     while (!*(nal_start++));
     nal_end = avc_find_startcode(nal_start, end);
-    av_format_ctx->put_be32(pb, nal_end - nal_start);
-    av_format_ctx->put_buffer(pb, nal_start, nal_end - nal_start);
+    av_format_ctx->avio_wb32(pb, nal_end - nal_start);
+    av_format_ctx->avio_write(pb, nal_start, nal_end - nal_start);
     size += 4 + nal_end - nal_start;
     nal_start = nal_end;
   }
@@ -537,14 +537,14 @@ const int avc_parse_nal_units_buf(DllAvUtil *av_util_ctx, DllAvFormat *av_format
   const uint8_t *buf_in, uint8_t **buf, int *size)
 {
   ByteIOContext *pb;
-  int ret = av_format_ctx->url_open_dyn_buf(&pb);
+  int ret = av_format_ctx->avio_open_dyn_buf(&pb);
   if (ret < 0)
     return ret;
 
   avc_parse_nal_units(av_format_ctx, pb, buf_in, *size);
 
   av_util_ctx->av_freep(buf);
-  *size = av_format_ctx->url_close_dyn_buf(pb, buf);
+  *size = av_format_ctx->avio_close_dyn_buf(pb, buf);
   return 0;
 }
 
@@ -590,26 +590,26 @@ const int isom_write_avcc(DllAvUtil *av_util_ctx, DllAvFormat *av_format_ctx,
       }
       assert(sps);
 
-      av_format_ctx->put_byte(pb, 1); /* version */
-      av_format_ctx->put_byte(pb, sps[1]); /* profile */
-      av_format_ctx->put_byte(pb, sps[2]); /* profile compat */
-      av_format_ctx->put_byte(pb, sps[3]); /* level */
-      av_format_ctx->put_byte(pb, 0xff); /* 6 bits reserved (111111) + 2 bits nal size length - 1 (11) */
-      av_format_ctx->put_byte(pb, 0xe1); /* 3 bits reserved (111) + 5 bits number of sps (00001) */
+      av_format_ctx->avio_w8(pb, 1); /* version */
+      av_format_ctx->avio_w8(pb, sps[1]); /* profile */
+      av_format_ctx->avio_w8(pb, sps[2]); /* profile compat */
+      av_format_ctx->avio_w8(pb, sps[3]); /* level */
+      av_format_ctx->avio_w8(pb, 0xff); /* 6 bits reserved (111111) + 2 bits nal size length - 1 (11) */
+      av_format_ctx->avio_w8(pb, 0xe1); /* 3 bits reserved (111) + 5 bits number of sps (00001) */
 
-      av_format_ctx->put_be16(pb, sps_size);
-      av_format_ctx->put_buffer(pb, sps, sps_size);
+      av_format_ctx->avio_wb16(pb, sps_size);
+      av_format_ctx->avio_write(pb, sps, sps_size);
       if (pps)
       {
-        av_format_ctx->put_byte(pb, 1); /* number of pps */
-        av_format_ctx->put_be16(pb, pps_size);
-        av_format_ctx->put_buffer(pb, pps, pps_size);
+        av_format_ctx->avio_w8(pb, 1); /* number of pps */
+        av_format_ctx->avio_wb16(pb, pps_size);
+        av_format_ctx->avio_write(pb, pps, pps_size);
       }
       av_util_ctx->av_free(start);
     }
     else
     {
-      av_format_ctx->put_buffer(pb, data, len);
+      av_format_ctx->avio_write(pb, data, len);
     }
   }
   return 0;
@@ -706,7 +706,7 @@ bool CDVDVideoCodecVDA::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
             }
 
             ByteIOContext *pb;
-            if (m_dllAvFormat->url_open_dyn_buf(&pb) < 0)
+            if (m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
             {
               return false;
             }
@@ -717,7 +717,7 @@ bool CDVDVideoCodecVDA::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
             // unhook from ffmpeg's extradata
             extradata = NULL;
             // extract the avcC atom data into extradata then write it into avcCData for VDADecoder
-            extrasize = m_dllAvFormat->url_close_dyn_buf(pb, &extradata);
+            extrasize = m_dllAvFormat->avio_close_dyn_buf(pb, &extradata);
             // CFDataCreate makes a copy of extradata contents
             avcCData = CFDataCreate(kCFAllocatorDefault, (const uint8_t*)extradata, extrasize);
             // done with the converted extradata, we MUST free using av_free
@@ -948,12 +948,12 @@ int CDVDVideoCodecVDA::Decode(BYTE* pData, int iSize, double dts, double pts)
       int demuxer_bytes;
       uint8_t *demuxer_content;
 
-      if(m_dllAvFormat->url_open_dyn_buf(&pb) < 0)
+      if(m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
       {
         return VC_ERROR;
       }
       demuxer_bytes = avc_parse_nal_units(m_dllAvFormat, pb, pData, iSize);
-      demuxer_bytes = m_dllAvFormat->url_close_dyn_buf(pb, &demuxer_content);
+      demuxer_bytes = m_dllAvFormat->avio_close_dyn_buf(pb, &demuxer_content);
       avc_demux = CFDataCreate(kCFAllocatorDefault, demuxer_content, demuxer_bytes);
       m_dllAvUtil->av_free(demuxer_content);
     }
@@ -961,7 +961,7 @@ int CDVDVideoCodecVDA::Decode(BYTE* pData, int iSize, double dts, double pts)
     {
       // convert demuxer packet from 3 byte NAL sizes to 4 byte
       ByteIOContext *pb;
-      if (m_dllAvFormat->url_open_dyn_buf(&pb) < 0)
+      if (m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
         return VC_ERROR;
 
       uint32_t nal_size;
@@ -970,14 +970,14 @@ int CDVDVideoCodecVDA::Decode(BYTE* pData, int iSize, double dts, double pts)
       while (nal_start < end)
       {
         nal_size = VDA_RB24(nal_start);
-        m_dllAvFormat->put_be32(pb, nal_size);
+        m_dllAvFormat->avio_wb32(pb, nal_size);
         nal_start += 3;
-        m_dllAvFormat->put_buffer(pb, nal_start, nal_size);
+        m_dllAvFormat->avio_write(pb, nal_start, nal_size);
         nal_start += nal_size;
       }
 
       uint8_t *demuxer_content;
-      int demuxer_bytes = m_dllAvFormat->url_close_dyn_buf(pb, &demuxer_content);
+      int demuxer_bytes = m_dllAvFormat->avio_close_dyn_buf(pb, &demuxer_content);
       avc_demux = CFDataCreate(kCFAllocatorDefault, demuxer_content, demuxer_bytes);
       m_dllAvUtil->av_free(demuxer_content);
     }
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.cpp
index 5f512fb..cca5318 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.cpp
@@ -474,7 +474,7 @@ int quicktime_write_mp4_descr_length(DllAvFormat *av_format_ctx, ByteIOContext *
     {
       b |= 0x80;
     }
-    av_format_ctx->put_byte(pb, b);
+    av_format_ctx->avio_w8(pb, b);
   }
 
   return numBytes; 
@@ -482,37 +482,37 @@ int quicktime_write_mp4_descr_length(DllAvFormat *av_format_ctx, ByteIOContext *
 
 void quicktime_write_esds(DllAvFormat *av_format_ctx, ByteIOContext *pb, quicktime_esds_t *esds)
 {
-  av_format_ctx->put_byte(pb, 0);     // Version
-  av_format_ctx->put_be24(pb, 0);     // Flags
+  av_format_ctx->avio_w8(pb, 0);     // Version
+  av_format_ctx->avio_wb24(pb, 0);     // Flags
 
   // elementary stream descriptor tag
-  av_format_ctx->put_byte(pb, 0x03);
+  av_format_ctx->avio_w8(pb, 0x03);
   quicktime_write_mp4_descr_length(av_format_ctx, pb,
     3 + 5 + (13 + 5 + esds->decoderConfigLen) + 3, false);
   // 3 bytes + 5 bytes for tag
-  av_format_ctx->put_be16(pb, esds->esid);
-  av_format_ctx->put_byte(pb, esds->stream_priority);
+  av_format_ctx->avio_wb16(pb, esds->esid);
+  av_format_ctx->avio_w8(pb, esds->stream_priority);
 
   // decoder configuration description tag
-  av_format_ctx->put_byte(pb, 0x04);
+  av_format_ctx->avio_w8(pb, 0x04);
   quicktime_write_mp4_descr_length(av_format_ctx, pb,
     13 + 5 + esds->decoderConfigLen, false);
   // 13 bytes + 5 bytes for tag
-  av_format_ctx->put_byte(pb, esds->objectTypeId); // objectTypeIndication
-  av_format_ctx->put_byte(pb, esds->streamType);   // streamType
-  av_format_ctx->put_be24(pb, esds->bufferSizeDB); // buffer size
-  av_format_ctx->put_be32(pb, esds->maxBitrate);   // max bitrate
-  av_format_ctx->put_be32(pb, esds->avgBitrate);   // average bitrate
+  av_format_ctx->avio_w8(pb, esds->objectTypeId); // objectTypeIndication
+  av_format_ctx->avio_w8(pb, esds->streamType);   // streamType
+  av_format_ctx->avio_wb24(pb, esds->bufferSizeDB); // buffer size
+  av_format_ctx->avio_wb32(pb, esds->maxBitrate);   // max bitrate
+  av_format_ctx->avio_wb32(pb, esds->avgBitrate);   // average bitrate
 
   // decoder specific description tag
-  av_format_ctx->put_byte(pb, 0x05);
+  av_format_ctx->avio_w8(pb, 0x05);
   quicktime_write_mp4_descr_length(av_format_ctx, pb, esds->decoderConfigLen, false);
-  av_format_ctx->put_buffer(pb, esds->decoderConfig, esds->decoderConfigLen);
+  av_format_ctx->avio_write(pb, esds->decoderConfig, esds->decoderConfigLen);
 
   // sync layer configuration descriptor tag
-  av_format_ctx->put_byte(pb, 0x06);  // tag
-  av_format_ctx->put_byte(pb, 0x01);  // length
-  av_format_ctx->put_byte(pb, 0x7F);  // no SL
+  av_format_ctx->avio_w8(pb, 0x06);  // tag
+  av_format_ctx->avio_w8(pb, 0x01);  // length
+  av_format_ctx->avio_w8(pb, 0x7F);  // no SL
 
   /* no IPI_DescrPointer */
 	/* no IP_IdentificationDataSet */
@@ -666,8 +666,8 @@ const int avc_parse_nal_units(DllAvFormat *av_format_ctx,
   {
     while (!*(nal_start++));
     nal_end = avc_find_startcode(nal_start, end);
-    av_format_ctx->put_be32(pb, nal_end - nal_start);
-    av_format_ctx->put_buffer(pb, nal_start, nal_end - nal_start);
+    av_format_ctx->avio_wb32(pb, nal_end - nal_start);
+    av_format_ctx->avio_write(pb, nal_start, nal_end - nal_start);
     size += 4 + nal_end - nal_start;
     nal_start = nal_end;
   }
@@ -678,14 +678,14 @@ const int avc_parse_nal_units_buf(DllAvUtil *av_util_ctx, DllAvFormat *av_format
   const uint8_t *buf_in, uint8_t **buf, int *size)
 {
   ByteIOContext *pb;
-  int ret = av_format_ctx->url_open_dyn_buf(&pb);
+  int ret = av_format_ctx->avio_open_dyn_buf(&pb);
   if (ret < 0)
     return ret;
 
   avc_parse_nal_units(av_format_ctx, pb, buf_in, *size);
 
   av_util_ctx->av_freep(buf);
-  *size = av_format_ctx->url_close_dyn_buf(pb, buf);
+  *size = av_format_ctx->avio_close_dyn_buf(pb, buf);
   return 0;
 }
 
@@ -770,26 +770,26 @@ const int isom_write_avcc(DllAvUtil *av_util_ctx, DllAvFormat *av_format_ctx,
       }
       assert(sps);
 
-      av_format_ctx->put_byte(pb, 1); /* version */
-      av_format_ctx->put_byte(pb, sps[1]); /* profile */
-      av_format_ctx->put_byte(pb, sps[2]); /* profile compat */
-      av_format_ctx->put_byte(pb, sps[3]); /* level */
-      av_format_ctx->put_byte(pb, 0xff); /* 6 bits reserved (111111) + 2 bits nal size length - 1 (11) */
-      av_format_ctx->put_byte(pb, 0xe1); /* 3 bits reserved (111) + 5 bits number of sps (00001) */
+      av_format_ctx->avio_w8(pb, 1); /* version */
+      av_format_ctx->avio_w8(pb, sps[1]); /* profile */
+      av_format_ctx->avio_w8(pb, sps[2]); /* profile compat */
+      av_format_ctx->avio_w8(pb, sps[3]); /* level */
+      av_format_ctx->avio_w8(pb, 0xff); /* 6 bits reserved (111111) + 2 bits nal size length - 1 (11) */
+      av_format_ctx->avio_w8(pb, 0xe1); /* 3 bits reserved (111) + 5 bits number of sps (00001) */
 
-      av_format_ctx->put_be16(pb, sps_size);
-      av_format_ctx->put_buffer(pb, sps, sps_size);
+      av_format_ctx->avio_wb16(pb, sps_size);
+      av_format_ctx->avio_write(pb, sps, sps_size);
       if (pps)
       {
-        av_format_ctx->put_byte(pb, 1); /* number of pps */
-        av_format_ctx->put_be16(pb, pps_size);
-        av_format_ctx->put_buffer(pb, pps, pps_size);
+        av_format_ctx->avio_w8(pb, 1); /* number of pps */
+        av_format_ctx->avio_wb16(pb, pps_size);
+        av_format_ctx->avio_write(pb, pps, pps_size);
       }
       av_util_ctx->av_free(start);
     }
     else
     {
-      av_format_ctx->put_buffer(pb, data, len);
+      av_format_ctx->avio_write(pb, data, len);
     }
   }
   return 0;
@@ -1086,7 +1086,7 @@ bool CDVDVideoCodecVideoToolBox::Open(CDVDStreamInfo &hints, CDVDCodecOptions &o
           ByteIOContext *pb;
           quicktime_esds_t *esds;
 
-          if (m_dllAvFormat->url_open_dyn_buf(&pb) < 0)
+          if (m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
             return false;
 
           esds = quicktime_set_esds(m_dllAvFormat, extradata, extrasize);
@@ -1095,7 +1095,7 @@ bool CDVDVideoCodecVideoToolBox::Open(CDVDStreamInfo &hints, CDVDCodecOptions &o
           // unhook from ffmpeg's extradata
           extradata = NULL;
           // extract the esds atom decoderConfig from extradata
-          extrasize = m_dllAvFormat->url_close_dyn_buf(pb, &extradata);
+          extrasize = m_dllAvFormat->avio_close_dyn_buf(pb, &extradata);
           free(esds->decoderConfig);
           free(esds);
 
@@ -1152,7 +1152,7 @@ bool CDVDVideoCodecVideoToolBox::Open(CDVDStreamInfo &hints, CDVDCodecOptions &o
             // NAL reformating to bitstream format required
 
             ByteIOContext *pb;
-            if (m_dllAvFormat->url_open_dyn_buf(&pb) < 0)
+            if (m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
               return false;
 
             m_convert_bytestream = true;
@@ -1161,7 +1161,7 @@ bool CDVDVideoCodecVideoToolBox::Open(CDVDStreamInfo &hints, CDVDCodecOptions &o
             // unhook from ffmpeg's extradata
             extradata = NULL;
             // extract the avcC atom data into extradata getting size into extrasize
-            extrasize = m_dllAvFormat->url_close_dyn_buf(pb, &extradata);
+            extrasize = m_dllAvFormat->avio_close_dyn_buf(pb, &extradata);
 
             // check for interlaced and get number of ref frames
             if (!validate_avcC_spc(extradata, extrasize, &m_max_ref_frames))
@@ -1301,17 +1301,17 @@ int CDVDVideoCodecVideoToolBox::Decode(BYTE* pData, int iSize, double dts, doubl
     if (m_convert_bytestream)
     {
       // convert demuxer packet from bytestream (AnnexB) to bitstream
-      if(m_dllAvFormat->url_open_dyn_buf(&pb) < 0)
+      if(m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
         return VC_ERROR;
 
       demux_size = avc_parse_nal_units(m_dllAvFormat, pb, pData, iSize);
-      demux_size = m_dllAvFormat->url_close_dyn_buf(pb, &demux_buff);
+      demux_size = m_dllAvFormat->avio_close_dyn_buf(pb, &demux_buff);
       sampleBuff = CreateSampleBufferFrom(m_fmt_desc, demux_buff, demux_size);
     }
     else if (m_convert_3byteTo4byteNALSize)
     {
       // convert demuxer packet from 3 byte NAL sizes to 4 byte
-      if (m_dllAvFormat->url_open_dyn_buf(&pb) < 0)
+      if (m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
         return VC_ERROR;
 
       uint32_t nal_size;
@@ -1320,13 +1320,13 @@ int CDVDVideoCodecVideoToolBox::Decode(BYTE* pData, int iSize, double dts, doubl
       while (nal_start < end)
       {
         nal_size = VDA_RB24(nal_start);
-        m_dllAvFormat->put_be32(pb, nal_size);
+        m_dllAvFormat->avio_wb32(pb, nal_size);
         nal_start += 3;
-        m_dllAvFormat->put_buffer(pb, nal_start, nal_size);
+        m_dllAvFormat->avio_write(pb, nal_start, nal_size);
         nal_start += nal_size;
       }
 
-      demux_size = m_dllAvFormat->url_close_dyn_buf(pb, &demux_buff);
+      demux_size = m_dllAvFormat->avio_close_dyn_buf(pb, &demux_buff);
       sampleBuff = CreateSampleBufferFrom(m_fmt_desc, demux_buff, demux_size);
     }
     else
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index b54b9bc..4f09346 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -330,7 +330,7 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput)
         pd.filename = strFile.c_str();
 
         // read data using avformat's buffers
-        pd.buf_size = m_dllAvFormat.get_buffer(m_ioContext, pd.buf, m_ioContext->max_packet_size ? m_ioContext->max_packet_size : m_ioContext->buffer_size);
+        pd.buf_size = m_dllAvFormat.avio_read(m_ioContext, pd.buf, m_ioContext->max_packet_size ? m_ioContext->max_packet_size : m_ioContext->buffer_size);
         if (pd.buf_size <= 0)
         {
           CLog::Log(LOGERROR, "%s - error reading from input stream, %s", __FUNCTION__, strFile.c_str());
@@ -339,7 +339,7 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput)
         memset(pd.buf+pd.buf_size, 0, AVPROBE_PADDING_SIZE);
 
         // restore position again
-        m_dllAvFormat.url_fseek(m_ioContext , 0, SEEK_SET);
+        m_dllAvFormat.avio_seek(m_ioContext , 0, SEEK_SET);
 
         // the advancedsetting is for allowing the user to force outputting the
         // 44.1 kHz DTS wav file as PCM, so that an A/V receiver can decode
-- 
1.7.10

